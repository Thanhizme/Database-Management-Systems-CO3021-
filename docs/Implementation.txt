================================================================================
3. IMPLEMENTATION AND PERFORMANCE OPTIMIZATION
================================================================================

This section details the practical steps taken to create and populate the 
LumbarMRI database, followed by performance analysis and optimization strategies.
The implementation is broken down into three main phases: database schema 
creation, data import from external sources, and performance optimization through
indexing.

--------------------------------------------------------------------------------
3.1 Database Deployment
--------------------------------------------------------------------------------

Unlike traditional SQL-only deployments, the LumbarMRI database combines 
SQL schema creation with Python-based ETL (Extract, Transform, Load) processes
to import medical imaging data and clinical notes from file systems and CSV
files.

3.1.1 Prerequisites
-------------------
- SQL Server with Windows Authentication
- Python 3.13+ with required packages:
  * pyodbc (SQL Server connectivity)
  * pandas (CSV data processing)
- ODBC Driver 17 for SQL Server
- Source data located in: D:\HK251\Database Management Systems (CO3021)\Dataset\


3.1.2 Phase 1: Database and Schema Creation
--------------------------------------------
Step 1: Create the database manually in SSMS:

    CREATE DATABASE LumbarMRI;
    GO

Step 2: Execute the schema creation script (create_schema.sql) which defines:
    - 5 core tables: Patients, Studies, Series, Images, RadiologistsData
    - Primary Keys (automatically creating Clustered Indexes on PK columns)
    - Foreign Key constraints to maintain referential integrity

Key Design Decisions:
    - Patients.PatientID: INT (not IDENTITY) - matches folder naming convention
    - Studies.StudyID: INT IDENTITY - auto-generated for each study
    - RadiologistsData.Note: NVARCHAR(MAX) NULL - supports long clinical text


3.1.3 Phase 2: MRI File System Data Import
-------------------------------------------
Script: script.py

Purpose: Scans the hierarchical MRI folder structure and extracts metadata
into the database.

Folder Structure Pattern:
    01_MRI_Data/
    ‚îî‚îÄ‚îÄ {PatientID}/                    # e.g., 0001, 0002
        ‚îî‚îÄ‚îÄ {StudyName_DateTime}/       # e.g., L-SPINE_LSS_20160309_091629
            ‚îî‚îÄ‚îÄ {SeriesName}/           # e.g., T2_TSE_SAG_384_0002
                ‚îî‚îÄ‚îÄ *.ima files         # Individual image files

Extraction Logic:
    1. Patient Detection:
       - Iterate through numeric folders (0001, 0002...)
       - Create Patient record if not exists

    2. Study Parsing:
       - Extract StudyName from folder name
       - Parse DateTime from pattern: YYYYMMDD_HHMMSS
       - Convert to SQL DATETIME type

    3. Series Classification:
       - Detect Orientation from series name:
         * 'SAG' ‚Üí Sagittal
         * 'TRA' ‚Üí Transverse  
         * 'BOX' ‚Üí Box
         * 'C-SPINE'/'L-SPINE' ‚Üí Spine
         * Default ‚Üí Unknown
       - Count .ima files in folder

    4. Image Registration:
       - Store full file path for each .ima file
       - Link to parent Series via Foreign Key

Import Results:
    - 515 Patients (with MRI data)
    - 558 Studies
    - 3,761 Series
    - 48,345 Images (.ima files)

Runtime: ~2-3 minutes (depends on I/O performance)


3.1.4 Phase 3: Clinical Data Import
------------------------------------
Script: import_radiologists_data.py

Purpose: Import radiologist clinical notes from CSV file into the database.

Source File: RadiologistsData.csv
Format:
    Patient ID,Clinician's Notes
    1,"L4-5: degenerative annular disc bulge..."
    2,"No evidence of disc herniation..."

Import Features:
    1. Automatic Patient Creation:
       - If CSV contains PatientID not in Patients table ‚Üí create new patient
       - Ensures referential integrity before inserting notes
    
    2. NULL Handling:
       - Empty notes stored as NULL (not empty string)
       - Distinguishes between "no note" vs "note exists but empty"

    3. Foreign Key Enforcement:
       - RadiologistsData.PatientID ‚Üí Patients.PatientID
       - Prevents orphaned clinical notes

Import Results:
    - 575 total records imported
    - 515 records matched existing patients (from MRI data)
    - 60 new patients created (have clinical notes but no MRI scans)
    - 515 notes with content, 60 NULL notes

Data Integrity Check:
    - 100% of patients have radiologist records
    - 89.6% have actual note content (515/575)
    - 10.4% have NULL notes (patients created during import)


3.1.5 Cleanup and Reset
------------------------
To reset the database for testing:

    DROP DATABASE LumbarMRI;
    GO

Then re-run all deployment steps from 3.1.2.


--------------------------------------------------------------------------------
3.2 Methodology for Performance Analysis
--------------------------------------------------------------------------------

The core of database optimization lies in understanding HOW the Database 
Management System (DBMS) executes queries. SQL Server provides the Actual 
Execution Plan as the primary diagnostic tool.

3.2.1 Enabling Execution Plans in SSMS
---------------------------------------
Method 1: Keyboard Shortcut
    - Press Ctrl+M before executing query
    
Method 2: Toolbar Button
    - Click "Include Actual Execution Plan" icon in SSMS toolbar

Method 3: T-SQL Command
    SET STATISTICS IO ON;
    SET STATISTICS TIME ON;
    -- Your query here
    SET STATISTICS IO OFF;
    SET STATISTICS TIME OFF;


3.2.2 Reading the Execution Plan
---------------------------------
The execution plan displays as a graphical tree, read from RIGHT to LEFT.
Each node represents an operation performed by the query optimizer.


3.2.3 Key Operators and Their Performance Implications
-------------------------------------------------------

üî¥ BAD OPERATORS (Optimization Targets):

1. Table Scan / Clustered Index Scan
   - What it means: DBMS reads EVERY row in the table
   - Analogy: "L·∫≠t t·ª´ng trang s√°ch t·ª´ ƒë·∫ßu ƒë·∫øn cu·ªëi"
   - Cost: O(n) - Linear time complexity
   - When it appears: No suitable index exists for filtering
   - Example scenario:
     
     SELECT * FROM Images WHERE FileName LIKE '%001.ima';
     
     Without index on FileName ‚Üí Full table scan (48,345 rows read)

2. Key Lookup (RID Lookup / Bookmark Lookup)
   - What it means: Index found the rows, but must go back to table for columns
   - Analogy: "D√πng m·ª•c l·ª•c ƒë·ªÉ t√¨m trang, nh∆∞ng ph·∫£i quay l·∫°i s√°ch ƒë·ªÉ ƒë·ªçc n·ªôi dung"
   - Cost: Extra I/O for each row
   - When it appears: Index exists but is not COVERING
   - Example scenario:
     
     SELECT FileName, FilePath FROM Images WHERE SeriesID = 100;
     
     If index exists only on SeriesID ‚Üí Seeks index, then looks up FilePath


‚úÖ GOOD OPERATORS (Optimization Goals):

1. Index Seek
   - What it means: DBMS jumps directly to required rows using an index
   - Analogy: "D√πng m·ª•c l·ª•c ƒë·ªÉ nh·∫£y th·∫≥ng ƒë·∫øn trang c·∫ßn t√¨m"
   - Cost: O(log n) - Logarithmic time complexity
   - When it appears: Appropriate index exists on WHERE/JOIN columns
   - Example scenario:
     
     SELECT * FROM Patients WHERE PatientID = 123;
     
     PatientID is PK ‚Üí Clustered Index Seek (instant lookup)

2. Index Scan (on small/filtered index)
   - What it means: Scans a smaller, filtered index instead of full table
   - Cost: O(m) where m << n (much smaller than table size)
   - When it appears: Filtered index or covering index is beneficial


3.2.4 Performance Metrics to Monitor
-------------------------------------

1. Logical Reads (from STATISTICS IO)
   - Number of 8KB pages read from memory
   - Lower is better
   - Example output:
     Table 'Images'. Scan count 1, logical reads 8543

2. Execution Time (from STATISTICS TIME)
   - CPU time vs Elapsed time
   - Example output:
     CPU time = 156 ms, elapsed time = 189 ms

3. Operator Cost (% in execution plan)
   - Each operator shows relative cost percentage
   - Focus optimization on operators with highest %


3.2.5 Baseline Performance Testing
-----------------------------------
Before optimization, establish baseline metrics for common queries:

Query Type 1: Patient Lookup
    SELECT * FROM Patients WHERE PatientID = 100;
    Baseline: Clustered Index Seek (already optimal - PK index)

Query Type 2: Find Studies by Date Range
    SELECT * FROM Studies 
    WHERE StudyDate BETWEEN '2016-01-01' AND '2016-12-31';
    Baseline: Clustered Index Scan (StudyDate not indexed)
    Logical Reads: ~1200 pages

Query Type 3: Find Series by Orientation
    SELECT * FROM Series WHERE Orientation = 'Sagittal';
    Baseline: Clustered Index Scan (Orientation not indexed)
    Logical Reads: ~800 pages

Query Type 4: Join Patient with Notes
    SELECT p.PatientID, r.Note
    FROM Patients p
    JOIN RadiologistsData r ON p.PatientID = r.PatientID
    WHERE p.PatientID = 50;
    Baseline: 2 Index Seeks (both PKs indexed)


3.2.6 Identifying Optimization Opportunities
---------------------------------------------
The methodology for finding optimization targets:

Step 1: Run representative queries with execution plan enabled
Step 2: Identify operators with >30% cost
Step 3: Look for patterns:
    - Table/Index Scans on large tables
    - Key Lookups appearing frequently
    - Missing indexes suggested by SSMS
Step 4: Analyze query WHERE/JOIN clauses
Step 5: Design appropriate indexes (covered in Case Studies)


--------------------------------------------------------------------------------
3.3 Index Design Principles for Medical Imaging Database
--------------------------------------------------------------------------------

3.3.1 Existing Indexes (Created Automatically)
-----------------------------------------------
Primary Key Constraints create Clustered Indexes:
    - Patients(PatientID) - Clustered Index
    - Studies(StudyID) - Clustered Index
    - Series(SeriesID) - Clustered Index
    - Images(ImageID) - Clustered Index
    - RadiologistsData(RecordID) - Clustered Index

Foreign Key columns are NOT automatically indexed!
    - Studies.PatientID - NO INDEX (optimization target)
    - Series.StudyID - NO INDEX (optimization target)
    - Images.SeriesID - NO INDEX (optimization target)
    - RadiologistsData.PatientID - NO INDEX (optimization target)


3.3.2 Index Strategy
---------------------
Based on query patterns, the following index types will be evaluated:

1. Non-Clustered Indexes on Foreign Keys
   - Improves JOIN performance
   - Eliminates scans when filtering by parent entity

2. Composite Indexes on (FK + Frequently Selected Columns)
   - Creates COVERING indexes
   - Eliminates Key Lookup operations

3. Filtered Indexes
   - Indexes only relevant subset of data
   - Example: Index only non-NULL notes

4. Indexes on Date Ranges
   - Supports temporal queries (common in medical data)


The following Case Studies (Section 4) will demonstrate practical 
implementation and measurement of these optimization strategies.

================================================================================
